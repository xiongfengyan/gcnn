# Copyright 2017 Wuhan Univeristy. All Rights Reserved.
# The code mainly implements some simple geometric calculations
# to support the python programming.
# 2017-12-16
# =====================================================

import math

# Define some interfaces that allow  other applications to use the Fourier transform
# Calculate the distance between object A and B.
# Args:
#   A=[x1,x2,...,xn]: The vector of object A.
#   B=[x1,x2,...,xn]: The vector of object B.
#                  e: The order.
# Output:
#   return the distance value.
def get_distance(A,B,e=1):
	dimension_size=len(A)
	if(dimension_size < 1 or dimension_size!=len(B)):
		print('ILLEGAL_ARGUMENT')
		return 0;
	dimension_sum=0
	for i in range(0,dimension_size):
		dimension_sum+=pow(abs(A[i]-B[i]),e)
	return round(pow(dimension_sum,1/e),4)

def get_area_of_Triangle(point1,point2,point3):
	area=0
	pp12=math.sqrt(math.pow(point1[0]-point2[0],2)+
					math.pow(point1[1]-point2[1],2))
	pp13=math.sqrt(math.pow(point1[0]-point3[0],2)+
					math.pow(point1[1]-point3[1],2))
	pp23=math.sqrt(math.pow(point2[0]-point3[0],2)+
					math.pow(point2[1]-point3[1],2))
	length=(pp12+pp13+pp23)/2
	ss=length*(length-pp12)*(length-pp13)*(length-pp23)
	if ss <=0:
		return 0
	else:
		return math.sqrt(ss)

def det(point1,point2,point3):
    return (point2[0]-point1[0])*(point3[1]-point1[1])-(point2[1]-point1[1])*(point3[0]-point1[0])

# A basic function for the calcalation of basic parametries of a polygon
# Args:
#   A=[[x1,y1],[x2,y2],...,[xn,yn]]: The input polygon
# Output:
#  [CX,CY]: The center point of the polygon.
#     area: The area of the polygon.
#     peri: The perimeter of the polygon.
def get_basic_parametries_of_Poly(A):
	CX,CY,area,peri=0,0,0,0
	if(len(A)<1):
		raise Exception('ILLEGAL_ARGUMENT')
		return [[CX,CY],area,peri]
	# closure the polygon.
	if(A[0][0]!=A[len(A)-1][0] or A[0][1]!=A[len(A)-1][1]):
		A.append(A[0])
	# calculate the center point [CX,CY] and perometry L.
	for i in range(0,len(A)-1):
		CX+=A[i][0]
		CY+=A[i][1]
		peri+=math.sqrt(pow(A[i+1][0]-A[i][0],2)+
						pow(A[i+1][1]-A[i][1],2))

	CX=CX/(len(A)-1)
	CY=CY/(len(A)-1)
	#calculate the area.
	if(len(A)<3):
		raise Exception('ILLEGAL_ARGUMENT')
		return [[CX,CY],area,peri]
	indication_point=A[0]
	for i in range(1,len(A)-1):
		#vector_pp1=[A[i][0]-A[0][0],A[i][1]-A[0][1]]
		#vector_pp2=[A[i+1][0]-A[0][0],A[i+1][1]-A[0][1]]
		#vector_cross=vector_pp1[0]*vector_pp2[1]-vector_pp1[1]*vector_pp2[0]
		#sign=0;
		#if(vector_cross>0):
		#	sign=1
		#else:
		#	sign=-1
		area+=det(indication_point,A[i],A[i+1])
	return [[CX,CY],abs(area)*0.5,abs(peri)]

def is_ClockWise_SubAlgorithm1(A):
	# print('subAlgorith1 begins')
	size=len(A)
	if(size<4):
		return False
	count=0
	for i in range(0,size):
		j,k=(i+1)%size,(i+2)%size
		z=(A[j][0]-A[i][0])*(A[k][1]-A[j][1])
		z-=(A[j][1]-A[i][1])*(A[k][0]-A[j][0])
		if(z<0):
			count-=1
		elif(z>0):
			count+=1
	if (count>0):
		return False
	else:
		return True

def is_ClockWise_SubAlgorithm2(A):
	# print('subAlgorith2 begins')
	size=len(A)
	if(size<4):
		return False
	s=0.0;
	for i in range(0,size):
		s+=(A[(i+1)%size][0]-A[i%size][0])*(A[(i+1)%size][1]+A[i%size][1])*0.5
	if (s>0):
		return True
	else:
		return False

def is_ClockWise_SubAlgorithm3(A):
	size=len(A)
	if(size<4):
		return False
	max_index,max_x=-1,-0.000000000001
	for i in range(0,size):
		if(A[i][0]>max_x):
			max_index,max_x=i,A[i][0]
	if(max_index<0):
		return False
	# calculate three points.
	cur_point,pre_point,next_point=A[max_index],[],[]
	j=max_index-1
	while j!= max_index:
		if(j==-1):
			j=size-1
		if (A[j][0]!=cur_point[0] or A[j][1]!=cur_point[1]):
			pre_point=A[j]
			break
		j-=1

	j=max_index+1
	while j!=max_index:
		if(j==size):
			j=0
		if (A[j][0]!=cur_point[0] or A[j][1]!=cur_point[1]):
			next_point=A[j]
			break
		j+=1

	# print('Is the loop aborted?')
	if(len(cur_point)<1 or len(pre_point)<1 or len(next_point)<1):
		return False
	v=(cur_point[0]-pre_point[0])*(next_point[1]-cur_point[1])\
		-(cur_point[1]-pre_point[1])*(next_point[0]-cur_point[0])
	if v<0:
		return False
	else:
		return True

def is_CloseWise(A):
	subAlgorith1 = is_ClockWise_SubAlgorithm1(A)
	subAlgorith2 = is_ClockWise_SubAlgorithm2(A)
	subAlgorith3 = not is_ClockWise_SubAlgorithm3(A)
	if (subAlgorith1==subAlgorith2 and subAlgorith2==subAlgorith3):
		return subAlgorith1
	else:
		#print('Warning: the result is generated by voting!')
		#print(subAlgorith1,subAlgorith2,subAlgorith3)
		vote=0
		if(subAlgorith1):
			vote+=1
		if(subAlgorith2):
			vote+=1
		if(subAlgorith3):
			vote+=1
		if (vote>1):
			return True
		else:
			return False
	return

class OBBOject:
	def __init__(self):
		self.u0,self.u1,self.c  = [0,0],[0,0],[0,0]
		self.e0,self.e1         = 0.0, 0.0
		# *_i represents index.
		self.minX_i,self.maxX_i = 0.0, 0.0
		self.minY_i,self.maxY_i = 0.0, 0.0

	# convert the descriptors to rectangle points.
	def toVertexes(self, isClose=True):
		vertexex=[]
		vertexex.append([self.c[0]+self.u0[0]*self.e0+self.u1[0]*self.e1,
						 self.c[1]+self.u0[1]*self.e0+self.u1[1]*self.e1])
		vertexex.append([self.c[0]+self.u0[0]*self.e0-self.u1[0]*self.e1,
						 self.c[1]+self.u0[1]*self.e0-self.u1[1]*self.e1])
		vertexex.append([self.c[0]-self.u0[0]*self.e0-self.u1[0]*self.e1,
						 self.c[1]-self.u0[1]*self.e0-self.u1[1]*self.e1])
		vertexex.append([self.c[0]-self.u0[0]*self.e0+self.u1[0]*self.e1,
						 self.c[1]-self.u0[1]*self.e0+self.u1[1]*self.e1])
		if isClose:
			vertexex.append([self.c[0]+self.u0[0]*self.e0+self.u1[0]*self.e1,
						 self.c[1]+self.u0[1]*self.e0+self.u1[1]*self.e1])
		return vertexex

	# calculate the point (index) that touched rectangle with the maximum X.
	# should pass the cooridates as an argument.
	def pointTouchRectWithMaxX(self, A):
		max_X,max_P = A[self.minX_i][0],self.minX_i
		if A[self.maxX_i][0] > max_X:
			max_X,max_P = A[self.maxX_i][0],self.maxX_i
		if A[self.minY_i][0] > max_X:
			max_X,max_P = A[self.minY_i][0],self.minY_i
		if A[self.maxY_i][0] > max_X:
			max_X,max_P = A[self.maxY_i][0],self.maxY_i
		return max_P

	def distanceOfPointFromRect(self, P):
		vertexex = self.toVertexes()
		min_Dis  = pointToLine(P,vertexex[3],vertexex[0])
		for i in range(0,3):
			if pointToLine(P,vertexex[i],vertexex[i+1])<min_Dis:
				min_Dis = pointToLine(P,vertexex[i],vertexex[i+1])
		return min_Dis

	def Orientation(self):
		if self.e0 > self.e1:
			if self.u0[1] > 0:
				return math.acos(self.u0[0])
			else:
				return math.pi - math.acos(self.u0[0])
		else:
			if self.u1[1] > 0:
				return math.acos(self.u1[0])
			else:
				return math.pi - math.acos(self.u1[0])

def Dot(u,v):
	return u[0]*v[0]+u[1]*v[1]

def pointToLine(P,P1,P2):
	a = math.sqrt(math.pow(P1[0]-P2[0],2)+math.pow(P1[1]-P2[1],2))
	b = math.sqrt(math.pow(P[0]-P1[0],2)+math.pow(P[1]-P1[1],2))
	c = math.sqrt(math.pow(P[0]-P2[0],2)+math.pow(P[1]-P2[1],2))
	if a==b+c:
		return 0.0
	if a==0:
		return b
	if c*c>=a*a+b+b:
		return b
	if b*b>=a*a+c*c:
		return c
	l=(a+b+c)/2
	# Take the absolute value just to ensure the accuracy.
	s=math.sqrt(abs(l*(l-a)*(l-b)*(l-c)))
	return 2*s/a

def mininumAreaRectangle(A):
	size,min_area = len(A),1.7976931348623157e+128
	i,j           = 0,size-1
	d,u0,u1       = [0,0],[0,0],[0,0]
	OBB=OBBOject()
	while i<size:
		length_edge=math.sqrt(pow(A[i][0]-A[j][0],2)+
							  pow(A[i][1]-A[j][1],2))
		if length_edge!=0:
			u0[0],u0[1]=(A[i][0]-A[j][0])/length_edge,(A[i][1]-A[j][1])/length_edge
			u1[0],u1[1]=0-u0[1],u0[0]
			#print(math.sqrt(u0[0]*u0[0]+u0[1]*u0[1]),u0[0]*u1[0]+u0[1]*u1[1])
			min0,max0,min1,max1,minX_i,maxX_i,minY_i,maxY_i=0.0,0.0,0.0,0.0,0,0,0,0
			for k in range(0,size):
				d[0],d[1]=A[k][0]-A[j][0],A[k][1]-A[j][1]
				# The projection onto the u0,u1.
				dotU0,dotU1=Dot(d,u0),Dot(d,u1)
				if dotU0<min0:
					min0,minX_i=dotU0,k
				if dotU0>max0:
					max0,maxX_i=dotU0,k
				if dotU1<min1:
					min1,minY_i=dotU1,k
				if dotU1>max1:
					max1,maxY_i=dotU1,k
			area=(max0-min0)*(max1-min1)
			if area < min_area:
				min_area=area
				# Update the information.
				OBB.c[0]=A[j][0]+(u0[0]*(max0+min0)+u1[0]*(max1+min1))*0.5
				OBB.c[1]=A[j][1]+(u0[1]*(max0+min0)+u1[1]*(max1+min1))*0.5
				OBB.u0,OBB.u1=[u0[0],u0[1]],[u1[0],u1[1]]
				OBB.e0,OBB.e1=(max0-min0)*0.5,(max1-min1)*0.5
				OBB.minX_i,OBB.maxX_i,OBB.minY_i,OBB.maxY_i=minX_i,maxX_i,minY_i,maxY_i
		j,i=i,i+1
	return OBB,min_area